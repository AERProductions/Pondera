/* sd_MapSuite
	by: Shadowdarke (shadowdarke@hotmail.com)

	A collection of map generation tools.

How to Make a Map With sd_MapSuite
==================================
For the most basic maps, you need only create an sd_MapMaker datum, modify any
settings you wish and call the Generate() proc.

For example, this proc is all you need to make a completely random map each
time it executes.
	mob/verb/makemap()
		var/sd_MapMaker/ClassicRogue/maker = new()
		maker.Generate()

1) Create the sd_MapMaker datum.
--------------------------------
The /sd_MapMaker datum itself is just the core and datum type. You must choose
a custom child type like the included /sd_MapMaker/ClassicRogue or
/sd_MapMaker/FullMaze types. Each custom child type produces a different style
of map, while the settings allow you to adjust how the map is generated.

The format for creating a new sd_MapMaker is
	New(LX = 1, HX = world.maxx, LY = 1,\
		HY = world.maxy, nZ = 1)

or alternately

	New(atom/Corner1, atom/Corner2)

All parameters are optional. It defaults to making a map from (1,1,1) to (maxx, maxy, 1).
You can specify two atoms that lie at oposite corners of the map region.

2) Modify the map settings.
---------------------------
You may fine tune (or further randomize) how your map is generated by changing
the sd_MapMaker's variables before calling Generate(). Specialized map types may have
additional variables for more control. Refer to the declaration for each datum type for details.

For example, if I wanted to make a rogue-like with a random number of nodes, I could modify the
above code as follows:
	mob/verb/makemap()
		var/sd_MapMaker/ClassicRogue/maker = new()
		maker.node_x = rand(5, round(world.mapx/2))
		maker.node_y = rand(5, round(world.mapy/2))
		maker.Generate()

3) Call the Generete() proc.
----------------------------
Each time the Generate proc is called, it will create a new random map in the defined region.


Tips For Faster Map Generation
==============================
*  Map smaller areas. It's faster to make 4 maps and peice them together than it is to make a
	single larger map in the same area.

*  Use larger nodes and borders (node_x, node_y, border_x and border_y.) This results in fewer
	nodes, which makes it easier to make sure they all connect.

*  Turn no_deadends off. It takes a lot of extra time to verify that there are no dead ends.

*  Use a higher open_chance. The more openings there are, the more likely it is that the map is
	already fully connected each check iteration.


Extra Features
==============
In addition to the basic mapmaker, sd_MapProcs contains a pair of procs that may be useful in
more generic routines. For instance, I use sd_PathTurfs to generate rivers in the overworld in
Darke Dungeon.

sd_GetEmptyTurf(z, minx = 1, miny = 1, maxx = world.maxx,\
	maxy = world.maxy, maxcount = 0, block = 0)

	This proc tries to find an non-dense turf that has nothing inside it within the block from
	(minx, miny, z) to (maxx, maxy, z).

	The maxcount argument allows you to specify how many times it attempts to get an empty
	turf before it gives up and returns a null value, indicating failure.

	If the block argument is set, then the proc will not return any turf that is between 2
	dense blocks either to the north and south or to the east and west.

	For example, if  # = dense   . = non-dense    * = test tile
	    .#.       ...       #..       ...
	 a) .*.    b) #*#    c) .*.    d) #*.
	    .#.       ...       ..#       .#.
	The * turf in a and b will not pass the block test, but the * turf in c and d will.

	All arguments but z are optional.


sd_PathTurfs(turf/start, turf/end, pathtype, min_width = 1,\
	max_width = 1, jaggedness=0, w_variance = 0, taper = 0)

	Creates a path from start to end. Intended For creating anything
	from a narrow dungeon corridors to winding caverns of varying width.

	ARGS:
		start			- beginning of the path
		end				- end of the path
		pathtype *		- If set, all turfs in this path will be
							replaced by a turf of pathtype
							DEFAULT: null (do not replace turfs,
										just make a list)
		min_width *		- minimum width of the path.
							DEFAULT: 1
		max_width *		- maximum width of the path/
							DEFAULT: 1
		jaggedness	*	- percent chance per step that the path will
							turn.
							DEFAULT: 0
		w_variance *	- percent chance per step that the width of
							the path will change.
							DEFAULT: 0
		taper *			- if set, the ends of the path will taper off

	RETURNS: associated list of all turfs in the path. The associated value is the direction
				(NORTH, SOUTH, EAST, or WEST) which the path passed through that turf.


	The path always goes in the cardinal directions.  That is,if the end is NORTHEAST of the
	start, the path will begin by either going NORTH or EAST and will have to make at least
	one turn, even if jaggedness is 0.

	No matter how high the jaggedness, the path will never turn away from the end. Once the
	path comes in line with the end along a cardinal direction, it become straight (though
	width variance may make it look ragged.)

		jaggedness 0				jaggedness 20%			jaggedness 100%

		......E		>>>>>>E			...>>>E					...>>>E
		......^		^......			...^...					..>^...
		......^		^......			...^...					.>^....
		......^		^......			...^...					>^.....
		S>>>>>^		S......			S>>^...					S......


Creating New sd_MapMaker Types (ADVANCED)
=========================================
sd_MapMaker maps make use of the sd_MapMatrix to guarantee connectivity, but there is a lot of
flexibility in how you actually create those connections, as you can see in the contrast between
a full maze style map versus a rogue-like map.

The sd_MapMaker uses 3 procs in the generation process. You should probably leave the Generate()
proc alone, unless you want to abandon the sd_MapMatrix altogether. Generate calls BuildMatrix(),
calls the matrix's Connect() proc, and then calls Matrix2Map() to project the matrix to the map.
BuildMatrix() and Matrix2Map() are the procs you want to change to make your custom map types.

BuildMatrix()
-------------
BuildMatrix() does exactly what you'd expect. It creates and returns a matrix of the appropriate
size for the map area bound by the sd_MapMaker.

There are a few things to remember about the matrix size. The matrix has one space for each node
and each border between nodes, as well as the borders around the edges, so the size of the matrix
should be 2 * (horizontal nodes) + 1 by 2 * (vertical nodes) + 1

For a 3 x 2 node matrix, you want to set the matrix to 7 x 5.

					1234567
				  5 *-*-*-*		* A column, where horizontal and vertical borders meet
				  4 |.|.|.|		- Horizontal border between nodes or the edge
				  3 *-*-*-*		| Vertical border between nodes or the edge
				  2 |.|.|.|		. A node of the map.
				  1 *-*-*-*

The nodes are empty space or perhaps a special shaped room. Columns are always walls, unless you
clear them away, like the clear_columns check for the Full Maze style.

After the matrix is created, BuildMatrix() should perform any special events that modify the
connection matrix, like the makerooms() call that you will find in the BuildMatrix() proc FullMaze
style.

BuildMatrix() should return the matrix, or the map generation will fail.

Matrix2Map()
------------
Matrix2Map() takes the connectivity matrix and projects it onto the map. For most maps (especially
rogue-like style), you could project the same matrix to the map multiple times and have very
different looking results though the connections between nodes are exactly the same. That's because
Matrix2Map() determines HOW the nodes are connected. This is the fundamental departure between the
Full Maze style and the Rogue-like style.

You should examine both existing map types to see how they read the matrix and convert its data into
actual turfs on the map.
*/