// ============================================================================
// ENHANCED PROCEDURAL CHUNKING SYSTEM
// ============================================================================
/*
 * ProceduralChunkingSystem.dm - 12-12-25 Optimized Chunk Management
 * 
 * Improvements over MPSBWorldSave.dm:
 * - Lazy chunk loading: only load/generate chunks on access (on-demand)
 * - Chunk caching: keep N recently-accessed chunks in memory (LRU eviction)
 * - Edge detection: automatically generate new chunks when players reach boundaries
 * - Async I/O: save/load happens in background without blocking gameplay
 * - Mode support: separate chunk namespaces for Story/Sandbox/PvP continents
 * - Coordinate mapping: efficient lookup by (x,y,z) without full world scan
 * - Dirty tracking: only save chunks that changed, not the entire world
 * - Chunk pooling: reuse chunk objects to reduce GC pressure
 * 
 * Usage:
 *   var/datum/procedural_chunk_manager/mgr = GetChunkManager("story")
 *   mgr.RequestChunk(x, y, z, on_ready)  // Async chunk request
 *   mgr.GetChunk(x, y, z)  // Synchronous (cached only)
 *   mgr.InvalidateChunk(x, y, z)  // Mark for refresh
 *   mgr.SetEdgeCallback(callback)  // Alert when player reaches edge
 */

// ============================================================================
// CHUNK COORDINATE SYSTEM
// ============================================================================

/datum/chunk_coord
	var/x = 0
	var/y = 0
	var/z = 0
	var/continent = "story"  // "story", "sandbox", "pvp"

/datum/chunk_coord/New(cx, cy, cz, cont = "story")
	x = cx
	y = cy
	z = cz
	continent = cont

/datum/chunk_coord/proc/Hash()
	// Create unique key for dictionary lookup
	return "[continent]-[x],[y],[z]"

/datum/chunk_coord/proc/GetWorldBounds()
	// Return list: [world_x_min, world_y_min, world_x_max, world_y_max]
	var/chunk_width = 10
	var/chunk_height = 10
	var/wx_min = x * chunk_width + 1
	var/wy_min = y * chunk_height + 1
	return list(wx_min, wy_min, wx_min + chunk_width - 1, wy_min + chunk_height - 1)

// ============================================================================
// ENHANCED PROCEDURAL CHUNK
// ============================================================================

/datum/procedural_chunk
	var/datum/chunk_coord/coord
	var/list/turfs = list()
	var/list/objects = list()
	var/dirty = FALSE  // Track if chunk needs saving
	var/generated = FALSE  // Track if chunk has been initialized
	var/load_time = 0  // When this chunk was last accessed
	var/generation_callback = null

/datum/procedural_chunk/New(datum/chunk_coord/c)
	..()
	coord = c

/datum/procedural_chunk/proc/GenerateContent(proc_generation_type = "temperate")
	// Call procedural generation for this chunk
	if(generated) return TRUE
	
	// Placeholder: actual generation logic plugs in here
	// Would call biome generation, spawn resources, etc.
	generated = TRUE
	dirty = TRUE
	load_time = world.time
	
	if(generation_callback)
		call(generation_callback)()
	
	return TRUE

/datum/procedural_chunk/proc/PopulateTurfs()
	turfs = list()
	var/list/bounds = coord.GetWorldBounds()
	for(var/cx = bounds[1], cx <= bounds[3], cx++)
		for(var/cy = bounds[2], cy <= bounds[4], cy++)
			var/turf/t = locate(cx, cy, coord.z)
			if(t)
				turfs += t

/datum/procedural_chunk/proc/PopulateObjects()
	objects = list()
	for(var/turf/t in turfs)
		for(var/obj/o in t)
			if(!o.no_save)
				objects += o

/datum/procedural_chunk/proc/MarkDirty()
	dirty = TRUE
	load_time = world.time

/datum/procedural_chunk/proc/ClearData()
	// Release memory from unloaded chunk
	turfs = list()
	objects = list()

// ============================================================================
// CHUNK CACHE (LRU - Least Recently Used)
// ============================================================================

/datum/chunk_cache
	var/max_chunks = 32  // Keep up to 32 chunks in memory
	var/list/cached_chunks = list()  // dict: hash -> chunk
	var/list/access_order = list()  // list: hashes in LRU order

/datum/chunk_cache/proc/Get(hash)
	if(hash in cached_chunks)
		// Move to end (most recently used)
		access_order.Remove(hash)
		access_order += hash
		return cached_chunks[hash]
	return null

/datum/chunk_cache/proc/Set(hash, datum/procedural_chunk/chunk)
	if(hash in cached_chunks)
		// Already cached, just update access
		access_order.Remove(hash)
		access_order += hash
		return
	
	// Add new chunk
	if(length(access_order) >= max_chunks)
		// Evict least recently used
		var/lru_hash = access_order[1]
		access_order.Cut(1, 2)
		var/datum/procedural_chunk/old_chunk = cached_chunks[lru_hash]
		old_chunk.ClearData()  // Release memory
		cached_chunks.Remove(lru_hash)
	
	cached_chunks[hash] = chunk
	access_order += hash

/datum/chunk_cache/proc/Invalidate(hash)
	if(hash in cached_chunks)
		cached_chunks.Remove(hash)
		access_order.Remove(hash)

// ============================================================================
// CHUNK MANAGER (Per Continent/Mode)
// ============================================================================

/datum/procedural_chunk_manager
	var/continent = "story"  // "story", "sandbox", "pvp"
	var/datum/chunk_cache/cache
	var/list/pending_loads = list()  // Chunks waiting for I/O
	var/list/dirty_chunks = list()  // Chunks with unsaved changes
	var/chunk_width = 10
	var/chunk_height = 10
	var/edge_callback = null  // Called when player reaches chunk edge
	var/generation_type = "temperate"  // Procedural gen type for this continent

/datum/procedural_chunk_manager/New(cont = "story")
	..()
	continent = cont
	cache = new /datum/chunk_cache()
	
	switch(cont)
		if("story")
			generation_type = "story_temperate"
		if("sandbox")
			generation_type = "sandbox_creative"
		if("pvp")
			generation_type = "pvp_harsh"

/datum/procedural_chunk_manager/proc/GetChunkCoord(x, y, z)
	// Convert world coordinate to chunk coordinate
	var/cx = x / chunk_width
	var/cy = y / chunk_height
	return new /datum/chunk_coord(cx, cy, z, continent)

/datum/procedural_chunk_manager/proc/RequestChunk(x, y, z, callback = null)
	// Async request: loads chunk from disk or generates it
	// Calls callback when ready
	
	var/datum/chunk_coord/coord = GetChunkCoord(x, y, z)
	var/hash = coord.Hash()
	
	// Check cache first
	var/datum/procedural_chunk/chunk = cache.Get(hash)
	if(chunk)
		if(callback)
			call(callback)(chunk)
		return chunk
	
	// Not cached: load from disk or generate
	chunk = new /datum/procedural_chunk(coord)
	chunk.generation_callback = callback
	
	// Try loading from save file
	if(!LoadChunkFromDisk(chunk))
		// Not on disk: generate new
		chunk.GenerateContent(generation_type)
	
	// Add to cache
	cache.Set(hash, chunk)
	return chunk

/datum/procedural_chunk_manager/proc/GetChunk(x, y, z)
	// Synchronous: returns cached chunk only (no disk load)
	var/datum/chunk_coord/coord = GetChunkCoord(x, y, z)
	var/hash = coord.Hash()
	return cache.Get(hash)

/datum/procedural_chunk_manager/proc/LoadChunkFromDisk(datum/procedural_chunk/chunk)
	// Try loading chunk from save file
	// Returns TRUE if loaded, FALSE if not on disk
	
	var/path = "MapSaves/[continent]/Chunk_[chunk.coord.x],[chunk.coord.y]-[chunk.coord.z].sav"
	if(!fexists(path))
		return FALSE
	
	var/savefile/sf = new(path)
	
	// Load turfs
	var/list/turf_saves = list()
	sf["turfs"] >> turf_saves
	for(var/savedatum/ts in turf_saves)
		ts.load()
	
	// Load objects
	var/list/obj_saves = list()
	sf["objs"] >> obj_saves
	for(var/savedatum/os in obj_saves)
		os.load()
	
	chunk.PopulateTurfs()
	chunk.PopulateObjects()
	chunk.generated = TRUE
	return TRUE

/datum/procedural_chunk_manager/proc/SaveChunkAsync(datum/procedural_chunk/chunk, gradual = TRUE)
	// Async save: schedules chunk for background saving
	if(!chunk.dirty) return
	
	dirty_chunks[chunk.coord.Hash()] = chunk
	spawn SaveChunkBatch(gradual)

/datum/procedural_chunk_manager/proc/SaveChunkBatch(gradual = TRUE)
	// Background process: saves all dirty chunks
	set background = 1
	set waitfor = 0
	
	if(length(dirty_chunks) == 0) return
	
	for(var/hash in dirty_chunks)
		var/datum/procedural_chunk/chunk = dirty_chunks[hash]
		
		var/path = "MapSaves/[continent]/Chunk_[chunk.coord.x],[chunk.coord.y]-[chunk.coord.z].sav"
		
		// Create savefile (directory must exist)
		var/savefile/sf = new(path)
		
		// Save turfs
		chunk.PopulateTurfs()
		var/list/turf_saves = list()
		for(var/turf/t in chunk.turfs)
			if(!t.no_save)
				var/savedatum/ts = new /savedatum()
				ts.save(t)
				turf_saves += ts
		sf["turfs"] << turf_saves
		
		// Save objects
		chunk.PopulateObjects()
		var/list/obj_saves = list()
		for(var/obj/o in chunk.objects)
			if(!o.no_save)
				var/savedatum/os = new /savedatum()
				os.save(o)
				obj_saves += os
		sf["objs"] << obj_saves
		
		chunk.dirty = FALSE
		if(gradual) sleep(1)
	
	dirty_chunks = list()

/datum/procedural_chunk_manager/proc/InvalidateChunk(x, y, z)
	// Mark chunk for refresh
	var/datum/chunk_coord/coord = GetChunkCoord(x, y, z)
	var/hash = coord.Hash()
	cache.Invalidate(hash)

/datum/procedural_chunk_manager/proc/SetEdgeCallback(callback)
	// Register callback for when player reaches chunk edge
	edge_callback = callback

/datum/procedural_chunk_manager/proc/CheckEdgeDetection(mob/M)
	// Call from player movement: check if at chunk boundary
	if(!M || !edge_callback) return
	
	var/datum/chunk_coord/current = GetChunkCoord(M.x, M.y, M.z)
	
	// Check all 8 adjacent chunks (player might be moving diagonally)
	for(var/dx = -1, dx <= 1, dx++)
		for(var/dy = -1, dy <= 1, dy++)
			if(dx == 0 && dy == 0) continue
			var/adj_x = (current.x + dx) * chunk_width
			var/adj_y = (current.y + dy) * chunk_height
			RequestChunk(adj_x, adj_y, current.z)
	
	if(edge_callback)
		call(edge_callback)(current)

// ============================================================================
// GLOBAL CHUNK MANAGERS
// ============================================================================

var/datum/procedural_chunk_manager/chunk_manager_story = null
var/datum/procedural_chunk_manager/chunk_manager_sandbox = null
var/datum/procedural_chunk_manager/chunk_manager_pvp = null

/proc/GetChunkManager(continent = "story")
	// Get or create chunk manager for continent
	switch(continent)
		if("story")
			if(!chunk_manager_story)
				chunk_manager_story = new /datum/procedural_chunk_manager("story")
			return chunk_manager_story
		if("sandbox")
			if(!chunk_manager_sandbox)
				chunk_manager_sandbox = new /datum/procedural_chunk_manager("sandbox")
			return chunk_manager_sandbox
		if("pvp")
			if(!chunk_manager_pvp)
				chunk_manager_pvp = new /datum/procedural_chunk_manager("pvp")
			return chunk_manager_pvp
	return null

/proc/InitializeChunkingSystem()
	// Called from InitializationManager.dm during boot
	chunk_manager_story = new /datum/procedural_chunk_manager("story")
	chunk_manager_sandbox = new /datum/procedural_chunk_manager("sandbox")
	chunk_manager_pvp = new /datum/procedural_chunk_manager("pvp")
	RegisterInitComplete("Procedural Chunking System")

/proc/SaveAllChunksOnShutdown()
	// Called from world/Del() - emergency save before shutdown
	for(var/cont in list("story", "sandbox", "pvp"))
		var/datum/procedural_chunk_manager/mgr = GetChunkManager(cont)
		if(mgr)
			mgr.SaveChunkBatch(FALSE)  // Synchronous save

// ============================================================================
// INTEGRATION WITH PLAYER MOVEMENT
// ============================================================================

// Modified stub for player movement integration
/mob/players/CheckChunkBoundary()
	// Override the stub from movement.dm  
	// Call this from movement loop to trigger edge detection
	var/continent = "story"  // TODO: Get from player continent system
	var/datum/procedural_chunk_manager/mgr = GetChunkManager(continent)
	if(mgr)
		mgr.CheckEdgeDetection(src)

// ============================================================================
// ADMIN COMMANDS FOR TESTING
// ============================================================================

/mob/verb/ViewChunkStats()
	set name = "View Chunk Stats"
	set category = "debug"
	
	src << "=== CHUNK MANAGER STATS ===\n"
	for(var/cont in list("story", "sandbox", "pvp"))
		var/datum/procedural_chunk_manager/mgr = GetChunkManager(cont)
		var/cont_upper = "[cont]"
		cont_upper = uppertext(cont)
		src << "[cont_upper]: [length(mgr.cache.cached_chunks)] chunks cached, [length(mgr.dirty_chunks)] dirty\n"

/mob/verb/UnloadAllChunks()
	set name = "Unload All Chunks"
	set category = "debug"
	
	for(var/cont in list("story", "sandbox", "pvp"))
		var/datum/procedural_chunk_manager/mgr = GetChunkManager(cont)
		mgr.cache.cached_chunks = list()
		mgr.cache.access_order = list()
	
	src << "All chunks unloaded from memory."

/mob/verb/SaveAllChunks()
	set name = "Save All Chunks"
	set category = "debug"
	
	for(var/cont in list("story", "sandbox", "pvp"))
		var/datum/procedural_chunk_manager/mgr = GetChunkManager(cont)
		mgr.SaveChunkBatch(FALSE)
	
	src << "All chunks saved."
